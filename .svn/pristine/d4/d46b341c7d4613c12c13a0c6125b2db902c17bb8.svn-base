/*

dependency_graph.cpp ... Dependency graph generated by dynamic linking.

Copyright (C) 2009  KennyTM~

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

// The result will be in Pajek format.
// Yes, you'll need Windows for Pajek.

#include "MachO_File.h"
#include <utility>
#include <cstdio>
#include <tr1/unordered_map>
#include <cstring>

using namespace std;

int main (int argc, const char* argv[]) {
	if (argc >= 2 && strcmp(argv[1], "-h") == 0) {
		fprintf(stderr, "Usage: dependency_graph [<sys-root>]\n\nIn the stdin, type in the list of executables you want to check.\n");
	} else {
		string sysroot = string((argc <= 1) ? "" : argv[1]);
		
		tr1::unordered_map<string, int> nodelist;
		tr1::unordered_set<int> processedlist;
		int nodes = 0;
		vector<pair<int, int> > arclist;
		
		while (!feof(stdin)) {
			char filename_buffer[2048];
			fgets(filename_buffer, 2048, stdin);
			size_t filename_length = strlen(filename_buffer);
			if (filename_buffer[filename_length-1] == '\n')
				filename_buffer[filename_length-1] = '\0';
			
			string filename = string(filename_buffer);
			tr1::unordered_map<string, int>::const_iterator cit = nodelist.find(filename);
			
			bool need_insert_nodelist = false;
			int current_node_id = nodes;
			
			if (cit != nodelist.end()) {
				if (processedlist.find(cit->second) != processedlist.end())
					continue;
				else
					current_node_id = cit->second;
			} else
				need_insert_nodelist = true;
			

			try {
				MachO_File_Simple file = MachO_File_Simple(filename_buffer);
			
				if (!file.valid())
					fprintf(stderr, "Warning: %s is not a valid Mach-O file. Ignoring it.\n", filename_buffer);
				else {
					processedlist.insert(current_node_id);
					if (need_insert_nodelist)
						nodelist.insert(pair<string,int>(filename, current_node_id));
					++nodes;
					
					vector<string> links = file.linked_libraries(sysroot);
					for (vector<string>::const_iterator cit2 = links.begin(); cit2 != links.end(); ++ cit2) {
						tr1::unordered_map<string, int>::const_iterator cit3 = nodelist.find(*cit2);
						int other_node_id = nodes;
						if (cit3 == nodelist.end()) {
							nodelist.insert(pair<string,int>(*cit2, other_node_id));
							++nodes;
						} else
							other_node_id = cit3->second;
						arclist.push_back(pair<int,int>(current_node_id, other_node_id));
					}
				}
			} catch (const TRException& e) {
				fprintf(stderr, "A TRException was thrown for '%s'.\n", e.what());
				continue;
			}
			
		}
		
		printf("*NETWORK Dependency graph.\r\n");
		printf("*VERTICES %d\r\n", nodes);
		for (tr1::unordered_map<string, int>::const_iterator cit = nodelist.begin(); cit != nodelist.end(); ++ cit)
			printf(" %d \"%s\" # %s\r\n", cit->second+1, strrchr(cit->first.c_str(), '/')+1, cit->first.c_str());
		printf("*ARCS\r\n");
		for (vector<pair<int, int> >::const_iterator cit = arclist.begin(); cit != arclist.end(); ++ cit)
			printf(" %d %d 1\r\n", cit->first+1, cit->second+1);
	}
	
	return 0;
}